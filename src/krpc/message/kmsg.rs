pub(crate) mod error;
pub(crate) mod nodes;
pub(crate) mod response;
pub(crate) mod serde_extra;
pub(crate) mod socket_addr_wrapper;
mod tests;
use crate::{
    dht_node::{DhtNode, IPV4_DHT_NODE_BYTES_LEN},
    u160::U160,
};
use error::Error;
use nodes::CompactIPv4NodeInfo;
use response::KResponse;
use serde::{Deserialize, Deserializer, Serialize};
use serde_derive::{Deserialize, Serialize};
use socket_addr_wrapper::SocketAddrWrapper;
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};
use typed_builder::TypedBuilder;

pub const Q_ANNOUNCE_PEER: &'static str = "announce_peer";
pub const Q_PING: &'static str = "ping";
pub const Q_FIND_NODE: &'static str = "find_node";
pub const Q_GET_PEERS: &'static str = "get_peers";
//BEP44
pub const Q_PUT: &'static str = "put";
pub const Q_GET: &'static str = "get";

pub const Y_QUERY: &'static str = "q";
pub const Y_RESPONSE: &'static str = "r";
pub const Y_ERROR: &'static str = "e";

// Msg represents messages that nodes in the network send to each other as specified by the protocol.
// They are also referred to as the KRPC messages.
// There are three types of messages: QUERY, RESPONSE, ERROR
// The message is a dictonary that is then
// "bencoded" (serialization & compression format adopted by the BitTorrent)
// and sent via the UDP connection to peers.
//
// A KRPC message is a single dictionary with two keys common to every message and additional keys depending on the type of message.
// Every message has a key "t" with a string value representing a transaction ID.
// This transaction ID is generated by the querying node and is echoed in the response, so responses
// may be correlated with multiple queries to the same node. The transaction ID should be encoded as a short string of binary numbers, typically 2 characters are enough as they cover 2^16 outstanding queries. The other key contained in every KRPC message is "y" with a single character value describing the type of message. The value of the "y" key is one of "q" for query, "r" for response, or "e" for error.
// 3 message types:  QUERY, RESPONSE, ERROR
#[derive(TypedBuilder, Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]
pub struct KMessage {
    // required: transaction ID
    #[serde(default)] //some errors can cause blank tid
    #[serde(rename = "t")]
    pub transaction_id: String,

    // required: type of the message: q for QUERY, r for RESPONSE, e for ERROR
    #[serde(rename = "y")]
    #[builder(setter(into))]
    pub message_type: String,

    // Query method (one of 4: "ping", "find_node", "get_peers", "announce_peer")
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "q")]
    #[builder(default, setter(strip_option, into))]
    pub query_method: Option<String>,

    // named arguments sent with a query
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "a")]
    #[builder(default, setter(strip_option))]
    pub arguments: Option<MessageArgs>,

    // RESPONSE type only
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "r")]
    #[builder(default, setter(strip_option))]
    pub response: Option<KResponse>,

    // ERROR type only
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "e")]
    #[builder(default, setter(strip_option))]
    pub error: Option<Error>,

    // bep42: outgoing query: requestor ip, incoming query: our ip accodring to the remote
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "ip")]
    #[builder(default, setter(strip_option))]
    pub peer_ip: Option<SocketAddrWrapper>,

    // bep43: ro is a read only top level field
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(rename = "ro")]
    #[serde(deserialize_with = "serde_extra::bool_from_int")]
    #[serde(serialize_with = "serde_extra::int_from_bool")]
    #[builder(default, setter(strip_option))]
    pub read_only: Option<bool>,

    // non standard field found in the wild
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[serde(rename = "v")]
    #[builder(default, setter(skip))]
    pub version: Option<Vec<u8>>,
}

// MsgArgs are the query arguments.
#[derive(TypedBuilder, Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]
pub struct MessageArgs {
    pub id: U160, // ID of the querying Node

    // ID of the node sought
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    pub target: Option<U160>,

    // Senders torrent port
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    port: Option<u16>,

    // Use senders apparent DHT port
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(deserialize_with = "serde_extra::bool_from_int")]
    #[serde(serialize_with = "serde_extra::int_from_bool")]
    #[builder(default, setter(strip_option))]
    pub implied_port: Option<bool>,

    // Token received from an earlier get_peers query
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[builder(default, setter(strip_option))]
    pub token: Option<Vec<u8>>,

    // InfoHash of the torrent
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    pub info_hash: Option<U160>,

    #[serde(flatten)]
    #[builder(default)]
    pub bep44: MessageArgsBep44,
}

#[derive(TypedBuilder, Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]
pub struct MessageArgsBep44 {
    // Data stored in a put message (encoded size < 1000)
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[builder(default, setter(strip_option))]
    pub v: Option<Vec<u8>>,

    // Seq of a mutable msg
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    pub seq: Option<i64>,

    // CAS value of the message mutation
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    pub cas: Option<i64>,

    // ed25519 public key (32 bytes string) of a mutable msg
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[builder(default, setter(strip_option))]
    pub k: Option<Vec<u8>>,

    // <optional salt to be appended to "k" when hashing (string) a mutable msg
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[builder(default, setter(strip_option))]
    pub salt: Option<String>,

    // ed25519 signature (64 bytes string)
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[builder(default, setter(strip_option))]
    pub sig: Option<Vec<u8>>,
}
